1.集合与数组存储数据概述：
集合、数组都是对多个数据进行存储操作的结构，简称Java容器。
说明：此时的存储，主要是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi,数据库）
2.数组存储的特点：
一旦初始化后，其长度就确定了。
数组一旦定义好，其元素的类型也就确定了，我们也就只能操作指定类型的数据了。
比如：String[] arr ; int[] arr ;
3.数组存储的弊端：
一旦初始化后，其长度就不可修改。
数组中提供的方法非常有限，对于添加、删除、插入数据操作，非常不方便，同时效率不高。
数组存储数据的特点：有序、可重复，对于无序、不可重复的需求，不能满足。
4.集合存储的优点：
解决数组存储数据方面的弊端。
========================================================================================================================
Collection：向Collection接口的实现类的对象中添加数据obj时，要求obj所在的类重写equals方法。
contains()方法底层调用equals方法，比较值是否相等，Object中的equals方法比较的是地址是否相等(==)
求集合交集：c1.retainAll(c2) 并返回给当前集合(修改)
求集合差集：c1.removeAll(c2) 并返回给当前集合(修改)
========================================================================================================================
集合元素的遍历：使用迭代器Iterator接口
Iterable接口中定义了一个iterator(),该方法返回Iterator类型的接口
Collection接口实现了Iterable接口
========================================================================================================================
一、单列集合
1.Collection：单列集合，用来存储一个一个的对象
        List：存储有序的、可重复的数据。“动态”数组替换原有的数组。
            ArrayList：作为List接口的主要实现类，线程不安全的，效率高，底层使用Object[] elementData存储
            LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高，底层使用双向链表存储
            Vector：作为List接口的古老实现类，线程安全的，效率低，底层使用Object[] elementData存储
        Set：存储无序的、不可重复的数据
            HashSet：底层是数组+链表，作为Set接口的主要实现类，线程不安全，可以存储null值
                LinkedHashSet：作为HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历（假的有序）
                           对于频繁的遍历（双向链表），LinkedHashSet效率高于HashSet
            TreeSet：底层是红黑树，可以按照添加的对象指定属性，进行排序。
                向TreeSet中添加的数据，要求是相同类型的对象。
                两种排序方式：自然排序（实现Comparable接口的compareTo方法）、定制排序（实现Comparator接口的compare方法）
                自然排序中比较两个对象是否相同的标准是compareTo()方法返回0,不再是equals()方法
                定制排序中比较两个对象是否相同的标准是compare()方法返回0，不再是equals()方法
2.ArrayList源码分析
    2.1 jdk7 ArrayList list = new ArrayList();//底层创建了长度为10的Object[] elementData数组
        当容量大于10后进行扩容，扩容为原来的1.5倍即15，然后将数组中的数据复制到新的数组中
    2.2 jdk8 ArrayList list = new ArrayList();//底层创建了长度为0的Object[] elementData数组
        进行添加的时候才进行数组初始化，容量为10，后续扩容跟1.7一样
    小结：jdk7中ArrayList对象的创建类似于单例的饿汉式，而jdk8中ArrayList对象的创建类似于单例的懒汉式，
          延迟了数组的创建，节省了内存。
    建议：开发中使用带参数构造器的ArrayList，避免不必要的扩容，消耗时间和内存。
3.LinkedList源码分析：双向链表 next、pre指针
4.Vector源码分析：废弃不看，扩容是原来的2倍

ArrayList、LinkedList、Vector三者的区别？
相同：三个类都实现了List接口，存储数据的特点相同：有序的、可重复的数据。
不同：请见上边总结
简单总结：
1.ArrayList线程不安全、查找元素较快（通过数组下标）、涉及到数组扩容
2.LinkedList插入、删除速度较快、查找速度慢
3.Vector线程安全的ArrayList
========================================================================================================================
一、Set：存储无序、不可重复的数据
以HashSet为例
1.无序性：不等于随机性，存储的数据在底层数组中并非按照数组的索引顺序添加，而是根据数据的哈希值确定存储的位置。
2.不可重复性：保证添加的元素按照equals()判断时，不能true，即相同的元素只能添加一个。
二、添加元素的过程，以HashSet为例
我们向HashSet中添加元素a时，首先调用a元素所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出
HashSet底层数组中存放位置（即为索引位置），判断数组此位置上是否已经有元素，如果此位置上没有其他元素，则元素a添加成功。
如果此位置上有其他元素b（或以链表形式存在多个元素），则比较元素a与元素b的哈希值，如果hash不相同，则元素a添加成功，
如果hash相同，进而需要调用元素a所在类的equals()方法，如果equals方法返回true，则元素a添加失败，如果equals方法返回false，
则元素a添加成功。
jdk7与jdk8中元素a添加的位置不同
jdk7：元素a放到数组中，指向原来的元素，向头部添加。
jdk8：原来的元素在数组中，指向元素a，向尾部添加。
总结：七上八下。

要求向Set中添加的数据，其所在的类一定要重写hashCode()和equals()方法

HashSet的底层是HashMap，而HashMap的底层是数组+链表

红黑树：https://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html
========================================================================================================================
双列集合
Map：双列数据，存储key-value对的数据
    HashMap：作为Map的主要实现类，线程不安全的，效率高，可以null的key和value
        LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序实现遍历，原理在原有的HashMap底层结构基础上，添加了一对
                        指针，指向前一个和后一个。对于频繁的遍历操作，此类执行的效率高于HashMap。
    TreeMap：底层使用红黑树，保证按照添加的key-value对进行排序，实现排序遍历，按照key进行排序。自然排序和定制排序。
    Hashtable：作为古老的实现类，线程安全的，效率低,不能存储null的key和value
        Properties：常用来处理配置文件，key和value都是String类型。
========================================================================================================================


HashMap的底层：数组+链表（jdk7及之前）
               数组+链表+红黑树（jdk8）

Map结构的理解：
Map中的key：无序的，不可重复的，使用Set存储所有的key
Map中的value：无序的，可重复的。使用Collection存储所有的value
一个键值对：key-value构成了一个Entry对象
Map中的entry：无序的、不可重复的，使用Set存储所有的entry

Map中的key所在的类必须重写equals()和hashCode()，针对是HashMap。
如果是TreeMap的话则是compareTo()和compare()

========================================================================================================================
HashMap的底层实现原理？以jdk7为例说明：
HashMap map = new HashMap();
在实例化后，底层创建了长度为16的一维数组Entry[] table
...可能已经执行了多次put...
map.put(key1,value1);
首先调用key1所在类的hashCode()计算key1的哈希值，此哈希值在经过某种算法计算以后，得到Entry数组中的存放位置，如果此位置上
的数据为空，此时key1-value1添加成功。如果此位置上的数据不为空（意味着此位置上存在一个或多个数据（以链表形式存在）），比较
key1和已经存在的一个或多个哈希值，如果key1的哈希值与已经存在的数据的哈希值都不相同，则key1-value1添加成功。如果key1的哈希值
与已经存在的某个数据的哈希值相同，则调用key1所在类的equals方法比较，如果equals返回false，则key1-value1添加成功，如果equals方法
返回true，则将覆盖。
在不断的添加过程中，会涉及到扩容问题，默认的扩容方式，扩容为原来的2倍，并将原来的数据复制过来。

jdk8相较于jdk7在底层实现方面不同：
1.new HashMap()底层没有创建一个长度为16的数组
2.jdk8底层的数组是Node[]，而非Entry[]
3.首次调用put()方法时，底层创建长度为16的数组
4.jdk7底层结构只有数组+链表，jdk8底层结构数组+链表+红黑树
当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且 当前数组的长度 > 64 时，此时此位置上所有的数据改为使用红黑树。












